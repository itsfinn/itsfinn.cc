[{"id":0,"href":"/post/innodb-auto-increment-handling/","title":"InnoDB 如何处理 AUTO_INCREMENT","section":"Posts","content":" InnoDB 中的 AUTO_INCREMENT 处理 # InnoDB 提供了一种可配置的锁定机制，可以显着提高将行添加到具有 AUTO_INCREMENT 列的表的 SQL 语句的可伸缩性和性能。要对 InnoDB 表使用 AUTO_INCREMENT 机制，必须将 AUTO_INCREMENT 列定义为某个索引的第一列或唯一列，这样就可以在表上执行与索引 SELECT MAX(ai_col) 查找等效的操作以获得最大列值。索引不需要是 PRIMARY KEY 或 UNIQUE ，但为了避免 AUTO_INCREMENT 列中的重复值，建议使用这些索引类型。\n本节介绍 AUTO_INCREMENT 锁定模式、不同 AUTO_INCREMENT 锁定模式设置的使用含义以及 InnoDB 如何初始化 AUTO_INCREMENT 计数器。\nInnoDB AUTO_INCREMENT 锁定模式 # 本节介绍用于生成自动增量值的 AUTO_INCREMENT 锁定模式，以及每种锁定模式如何影响复制。自增锁定模式在启动时使用 innodb_autoinc_lock_mode 变量进行配置。\n以下术语用于描述 innodb_autoinc_lock_mode 设置：\n“INSERT-like”语句\n在表中生成新行的所有语句，包括 INSERT 、 INSERT \u0026hellip; SELECT 、 REPLACE 、 REPLACE \u0026hellip; SELECT 和 LOAD DATA 。包括“简单插入”、“批量插入”和“混合模式”插入。\n“简单插入”\n可以预先确定要插入的行数的语句（当语句最初被处理时）。这包括没有嵌套子查询的单行和多行 INSERT 和 REPLACE 语句，但不包括 INSERT \u0026hellip; ON DUPLICATE KEY UPDATE 。\n“批量插入”\n事先不知道要插入的行数（以及所需的自动增量值的数量）的语句。这包括 INSERT \u0026hellip; SELECT 、 REPLACE \u0026hellip; SELECT 和 LOAD DATA 语句，但不包括普通的 INSERT 。在处理每一行时， InnoDB 一次为 AUTO_INCREMENT 列分配一个新值。\n“混合模式插入”\n这些是“简单插入”语句，它们为一些（但不是全部）新行指定自动增量值。下面是一个示例，其中 c1 是表 t1 的 AUTO_INCREMENT 列：\n1 INSERT INTO t1 (c1,c2) VALUES (1,\u0026#39;a\u0026#39;), (NULL,\u0026#39;b\u0026#39;), (5,\u0026#39;c\u0026#39;), (NULL,\u0026#39;d\u0026#39;); 另一种类型的“混合模式插入”是 INSERT \u0026hellip; ON DUPLICATE KEY UPDATE ，在最坏的情况下，它实际上是一个 INSERT 后跟一个 UPDATE ，其中为 AUTO_INCREMENT 列分配的值可能会也可能不会被使用更新阶段。\ninnodb_autoinc_lock_mode 变量有三种可能的设置。 “传统”、“连续”或“交错”锁定模式的设置分别为 0、1 或 2。\ninnodb_autoinc_lock_mode = 0 （“传统”锁定模式）\n传统的锁定模式提供了与引入 innodb_autoinc_lock_mode 变量之前相同的行为。由于语义上可能存在差异，提供传统锁定模式选项是为了向后兼容、性能测试和解决“混合模式插入”的问题。\n在这种锁定模式下，所有“INSERT-like”的语句都获得一个特殊的表级 AUTO-INC 锁，用于插入到具有 AUTO_INCREMENT 列的表中。这个锁通常保持到语句的末尾（而不是事务的末尾），这样就可以保证, 当给定的多条 INSERT 语句顺序确定时, 给每条语句分配的值(自增列), 是可预测可重复的, 并且是连续的。\n对于基于语句的复制，这意味着当在副本服务器上复制 SQL 语句时，自动增量列使用与源服务器上相同的值。多个 INSERT 语句的执行结果是确定性的，副本重现与源相同的数据。如果由多个 INSERT 语句生成的自动增量值交错，则两个并发 INSERT 语句的结果将是不确定的，并且无法可靠地传播到使用基于语句的复制的副本服务器。\n为清楚起见，请考虑使用此表的示例：\n1 2 3 4 5 CREATE TABLE t1 ( c1 INT(11) NOT NULL AUTO_INCREMENT, c2 VARCHAR(10) DEFAULT NULL, PRIMARY KEY (c1) ) ENGINE=InnoDB; 假设有两个事务正在运行，每个事务都将行插入到具有 AUTO_INCREMENT 列的表中。一个事务使用插入 1000 行的 INSERT \u0026hellip; SELECT 语句，另一个事务使用插入一行的简单 INSERT 语句：\nTx1: INSERT INTO t1 (c2) SELECT 1000 rows from another table \u0026hellip;\nTx2: INSERT INTO t1 (c2) VALUES (\u0026lsquo;xxx\u0026rsquo;);\nInnoDB 无法预先知道在 Tx1 中的 INSERT 语句中从 SELECT 中检索了多少行，它会随着语句的进行一次分配一个自动增量值。使用表级锁，一直保持到语句末尾，一次只能执行一条引用 t1 表的 INSERT 语句，不同语句生成自增数不会交错。 Tx1 INSERT \u0026hellip; SELECT 语句生成的自增值是连续的，而 Tx2 中 INSERT 语句使用的（单个）自增值小于或大于所有用于 Tx1 的自增值，具体取决于哪个语句先执行。\n只要 SQL 语句在从二进制日志重播时（使用基于语句的复制时，或在恢复场景中）以相同的顺序执行，结果就与 Tx1 和 Tx2 首次运行时相同。因此，表级锁一直保持到语句结束，使 INSERT 语句使用自动增量安全地用于基于语句的复制。但是，当多个事务同时执行插入语句时，那些表级锁会限制并发性和可伸缩性。\n在前面的例子中，如果没有表级锁，那么Tx2中 INSERT 使用的自增列的值恰好取决于语句执行的时间。如果 Tx2 的 INSERT 在 Tx1 的 INSERT 运行时执行（而不是在它开始之前或完成之后），则两个 INSERT 语句分配的具体自动增量值是不确定的，并且可能与变来变去。\n在连续锁模式下， InnoDB 可以避免对行数预先已知的“简单插入”语句使用表级锁 AUTO-INC ，并且仍然保留确定的执行结果和基于语句的复制的安全性。\n如果您不使用二进制日志来重放 SQL 语句作为恢复或复制的一部分，则可以使用交错锁模式来消除对表级 AUTO-INC 锁的所有使用，以获得更高的并发性和性能，但代价是允许语句分配的自动递增数字中的间隙，并可能交错并发执行的语句分配的数字。\ninnodb_autoinc_lock_mode = 1 （“连续”锁定模式）\n这是默认的锁定模式。在这种模式下，“批量插入”使用特殊的 AUTO-INC 表级锁并将其保持到语句结束。这适用于所有 INSERT \u0026hellip; SELECT 、 REPLACE \u0026hellip; SELECT 和 LOAD DATA 语句。一次只能执行一条持有 AUTO-INC 锁的语句。如果批量插入操作的源表与目标表不同，则在对从源表中选择的第一行加共享锁后，再加对目标表的 AUTO-INC 锁。如果批量插入操作的源和目标是同一张表，那么 AUTO-INC 锁是在对所有选中的行加共享锁后加的。\n“简单插入”（预先知道要插入的行数）通过在互斥锁（mutex,轻量级锁,仅在分配自动增量值过程期间保留，不需要保留到语句完成）的控制下获取所需数量的自动增量值来避免表级 AUTO-INC 锁。除非另一个事务持有 AUTO-INC 锁，否则不使用表级 AUTO-INC 锁。如果另一个事务持有 AUTO-INC 锁，则“简单插入”会等待 AUTO-INC 锁，就好像它是“批量插入”一样。\n这种锁定模式确保，在存在行数事先未知的 INSERT 语句（所需的自动递增数字,随着语句的进行分配）的情况下，所有由任何“INSERT-like”语句分配的自动递增值是连续的，对于基于语句的复制是安全的。\n简而言之，这种锁定模式显着提高了可伸缩性，同时可以安全地用于基于语句的复制。此外，与“传统”锁定模式一样，任何给定语句分配的自动递增数字都是连续的。对于任何使用自动递增的语句，与“传统”模式相比，语义没有变化，但有一个重要的例外。\n例外情况是“混合模式插入”，其中用户为多行“简单插入”中的一些（但不是全部）行的 AUTO_INCREMENT 列提供显式值。对于此类插入， InnoDB 分配的自动增量值多于要插入的行数。但是，所有自动分配的值都是连续生成的（因此高于）由最近执行的先前语句生成的自动增量值。 “多余”的数字丢失了。\ninnodb_autoinc_lock_mode = 2 （“交错”锁定模式）\n在这种锁模式下，所有“INSERT-like”语句都不会使用表级 AUTO-INC 锁，多个语句可以同时执行。这是最快和最具扩展性的锁定模式，但在使用基于语句的复制或从二进制日志重放 SQL 语句的恢复场景时，它并不安全。\n在这种锁定模式下，InnoDB保证在所有并发执行的“INSERT-like” 语句中, 自增值是唯一且单调递增的。但是，由于多个语句可以同时生成数字（即，数字的分配在语句之间交错），因此一条插入多行记录的语句, 分配到值可能是不连续的。\n如果只执行一条“简单插入”语句，其中要插入的行数提前已知，则为单个语句生成的数字没有间隙，“混合模式插入”除外。但是，当执行“批量插入”时，任何给定语句分配的自动增量值可能存在间隙。\nInnoDB AUTO_INCREMENT 锁模式使用含义 # 在复制中使用自动增量\n如果您使用的是基于语句的复制，请将 innodb_autoinc_lock_mode 设置为 0 或 1 并在源及其副本服务器上使用相同的值。如果您使用 innodb_autoinc_lock_mode = 2（“交错”）或源和副本不使用相同锁定模式的配置，则不能确保副本上的自动增量值与源上的值相同。\n如果您使用基于行或混合格式的复制，所有的自增锁模式都是安全的，因为基于行的复制对 SQL 语句的执行顺序不敏感（并且对于混合格式的复制, 如果一条语句基于语句的复制是不安全的, 则会使用使用基于行的复制）。\n“丢失”的自动增量值和序列间隙\n在所有锁定模式（0、1 和 2）中，如果生成自动增量值的事务回滚，则这些自动增量值将“丢失”。自增列一旦产生值，就不能回滚，不管“INSERT-like”语句是否完成，也不管事务是否被执行回滚。这些丢失的值不会被重用。因此，存储在表的 AUTO_INCREMENT 列中的值可能存在间隙。\n为 AUTO_INCREMENT 列指定 NULL 或 0\n在所有锁定模式（0、1 和 2）中，如果用户为 INSERT 中的 AUTO_INCREMENT 列指定 NULL 或 0，则 InnoDB 将该行视为未指定值, 并为它生成一个新值。\n将负值分配给 AUTO_INCREMENT 列\n在所有锁定模式（0、1 和 2）中，如果将负值分配给 AUTO_INCREMENT 列，则自动递增机制的行为是未定义的。\n如果 AUTO_INCREMENT 值变得大于指定整数类型的最大整数\n在所有锁定模式（0、1 和 2）中，如果值变得大于可以存储在指定整数类型中的最大整数，则自动递增机制的行为是未定义的。\n“批量插入”的自动增量值差距\ninnodb_autoinc_lock_mode 设置为 0（“传统”）或 1（“连续”）时，任何给定语句生成的自动增量值都是连续的，没有间隙，因为表级 AUTO-INC 锁一直保持到结束的语句，并且一次只能执行一个这样的语句。\ninnodb_autoinc_lock_mode 设置为 2（“interleaved”）时，“批量插入”生成的自动增量值可能存在间隙，但前提是同时执行其他“INSERT-like”语句。\n对于锁定模式 1 或 2，连续语句之间可能会出现间隙，因为对于批量插入，可能不知道每个语句所需的自动增量值的确切数量，并且可能会高估。\n由“混合模式插入”分配的自动增量值\n考虑“混合模式插入”，其中“简单插入”指定某些（但不是全部）结果行的自动增量值。这样的语句在锁定模式 0、1 和 2 中的行为不同。例如，假设 c1 是表 t1 的 AUTO_INCREMENT 列，并且最近自动生成的序列号是 100。\n1 2 3 4 mysql\u0026gt; CREATE TABLE t1 ( -\u0026gt; c1 INT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY, -\u0026gt; c2 CHAR(1) -\u0026gt; ) ENGINE = INNODB; 现在，考虑以下“混合模式插入”语句：\n1 mysql\u0026gt; INSERT INTO t1 (c1,c2) VALUES (1,\u0026#39;a\u0026#39;), (NULL,\u0026#39;b\u0026#39;), (5,\u0026#39;c\u0026#39;), (NULL,\u0026#39;d\u0026#39;); innodb_autoinc_lock_mode 设置为 0（“传统”），四个新行是：\n1 2 3 4 5 6 7 8 9 mysql\u0026gt; SELECT c1, c2 FROM t1 ORDER BY c2; +-----+------+ | c1 | c2 | +-----+------+ | 1 | a | | 101 | b | | 5 | c | | 102 | d | +-----+------+ 下一个可用的自动增量值是 103，因为自动增量值是一次分配一个，而不是在语句执行开始时一次分配。无论是否同时执行“INSERT-like”语句（任何类型），此结果都是正确的。\ninnodb_autoinc_lock_mode 设置为 1（“连续”），四个新行也是：\n1 2 3 4 5 6 7 8 9 mysql\u0026gt; SELECT c1, c2 FROM t1 ORDER BY c2; +-----+------+ | c1 | c2 | +-----+------+ | 1 | a | | 101 | b | | 5 | c | | 102 | d | +-----+------+ 但是，在这种情况下，下一个可用的自动增量值是 105，而不是 103，因为在处理语句时分配了四个自动增量值，但只使用了两个。无论是否同时执行“INSERT-like”语句（任何类型），此结果都是正确的。\ninnodb_autoinc_lock_mode 设置为 2（“交错”），四个新行是：\n1 2 3 4 5 6 7 8 9 mysql\u0026gt; SELECT c1, c2 FROM t1 ORDER BY c2; +-----+------+ | c1 | c2 | +-----+------+ | 1 | a | | x | b | | 5 | c | | y | d | +-----+------+ x 和 y 的值是唯一的，并且比之前生成的任何行都大。但是 x 和 y 的具体取值取决于并发执行语句产生的自增值的个数。\n最后，考虑以下语句，在最近生成的序列号为 100 时发出：\n1 mysql\u0026gt; INSERT INTO t1 (c1,c2) VALUES (1,\u0026#39;a\u0026#39;), (NULL,\u0026#39;b\u0026#39;), (101,\u0026#39;c\u0026#39;), (NULL,\u0026#39;d\u0026#39;); 对于任何 innodb_autoinc_lock_mode 设置，此语句都会生成重复键错误 23000 ( Can\u0026rsquo;t write; duplicate key in table )，因为为行 (NULL, \u0026lsquo;b\u0026rsquo;) 分配了 101，而行 (101, \u0026lsquo;c\u0026rsquo;) 的插入失败。\n修改 INSERT 语句序列中间的 AUTO_INCREMENT 列值\n在所有锁定模式（0、1 和 2）中，修改 INSERT 语句序列中间的 AUTO_INCREMENT 列值可能会导致“重复输入”错误。例如，如果执行 UPDATE 操作将 AUTO_INCREMENT 列值更改为大于当前最大自动增量值的值，则后续未指定未使用的自动增量值的 INSERT 操作可能会遇到“重复输入”错误。以下示例演示了此行为。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 mysql\u0026gt; CREATE TABLE t1 ( -\u0026gt; c1 INT NOT NULL AUTO_INCREMENT, -\u0026gt; PRIMARY KEY (c1) -\u0026gt; ) ENGINE = InnoDB; mysql\u0026gt; INSERT INTO t1 VALUES(0), (0), (3); mysql\u0026gt; SELECT c1 FROM t1; +----+ | c1 | +----+ | 1 | | 2 | | 3 | +----+ mysql\u0026gt; UPDATE t1 SET c1 = 4 WHERE c1 = 1; mysql\u0026gt; SELECT c1 FROM t1; +----+ | c1 | +----+ | 2 | | 3 | | 4 | +----+ mysql\u0026gt; INSERT INTO t1 VALUES(0); ERROR 1062 (23000): Duplicate entry \u0026#39;4\u0026#39; for key \u0026#39;PRIMARY\u0026#39; InnoDB AUTO_INCREMENT 计数器初始化 # 本节介绍 InnoDB 如何初始化 AUTO_INCREMENT 计数器。\n如果为 InnoDB 表指定 AUTO_INCREMENT 列，则 InnoDB 数据字典中的表句柄包含一个称为自动递增计数器的特殊计数器，用于为该列分配新值。该计数器仅存储在主内存中，而不存储在磁盘上。\n为了在服务器重新启动后初始化一个自动递增计数器， InnoDB 在第一次插入包含 AUTO_INCREMENT 列的表时执行与以下语句等效的语句。\n1 SELECT MAX(ai_col) FROM table_name FOR UPDATE; InnoDB 递增语句检索的值并将其分配给列和表的自动递增计数器。默认情况下，该值递增 1。可以通过 auto_increment_increment 配置设置覆盖此默认值。\n如果表为空， InnoDB 使用值 1 。这个默认值可以被 auto_increment_offset 配置设置覆盖。\n如果 SHOW TABLE STATUS 语句在自动递增计数器初始化之前检查表，则 InnoDB 初始化但不递增该值。存储该值供以后插入使用。此初始化在表上使用正常的独占锁定读取，锁定持续到事务结束。 InnoDB 遵循相同的过程为新创建的表初始化自动递增计数器。\n自动递增计数器初始化后，如果您没有明确指定 AUTO_INCREMENT 列的值， InnoDB 会递增计数器并将新值分配给该列。如果插入一行明确指定列值，并且该值大于当前计数器值，则计数器设置为指定的列值。\n只要服务器运行， InnoDB 就会使用内存中的自动递增计数器。当服务器停止并重新启动时， InnoDB 为第一个 INSERT 重新初始化每个表的计数器，如前所述。\n服务器重新启动还会取消 CREATE TABLE 和 ALTER TABLE 语句中 AUTO_INCREMENT = N 表选项的影响，您可以将其与 InnoDB 表一起使用以设置初始计数器值或更改当前计数器值。\n注释 # 当 AUTO_INCREMENT 整数列用完值时，后续的 INSERT 操作将返回重复键错误。这是一般的 MySQL 行为。\n当您重新启动 MySQL 服务器时， InnoDB 可能会重用为 AUTO_INCREMENT 列生成但从未存储的旧值（即，在回滚的旧事务期间生成的值）。\n"},{"id":1,"href":"/post/kubernetes-resource-name-spec/","title":"k8s资源名称规范","section":"Posts","content":" 汇总表格 # 类型 中文名称 英文名称 最大长度 正则表达式/备注 DNS子域名 Pod Pod 253 ^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$ ConfigMap 253 同上 网络策略 NetworkPolicy 253 同上 RFC 1123 标签名 服务 Service 63 命名空间 Namespace 63 RFC 1035 标签名 63 路径分段名称 Role RoleBinding ClusterRole ClusterRoleBinding helm 应用名称 应用名称 53 ^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$ 其他 注解键 Annotations Key 317 长度(253+1+63), 值无限制 注解前缀 Annotations Prefix 253 正则同 DNS子域名, 值无限制 注解名称 Annotations Name 63 正则同标签名称, 值无限制 标签 Label 381 长度(253+1+63+1+63) 标签键 Label Key 253 正则同 DNS子域名 标签名称 Label Name 63 ^([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9]$ 标签值 Label Value 63 同标签名称 端口名称 Port Name 15 对象名称和 IDs | Kubernetes # 以下是比较常见的四种资源命名约束。\nDNS 子域名【长度253】 # 正则表达式：^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$\n很多资源类型需要可以用作 DNS 子域名的名称。 DNS 子域名的定义可参见 RFC 1123。 这一要求意味着名称必须满足如下规则：\n不能超过 253 个字符 只能包含小写字母、数字，以及 \u0026lsquo;-\u0026rsquo; 和 \u0026lsquo;.\u0026rsquo; 必须以字母数字开头 必须以字母数字结尾 DNS子域名多级使用 “.” 连接，每一级以字母数字开头，以字母数字结尾，“-”只能出现在每一级的中间 相关资源类型：\nPod名称 参考自 https://kubernetes.io/zh/docs/concepts/workloads/pods/ 当你为 Pod 对象创建清单时，要确保所指定的 Pod 名称是合法的 DNS 子域名。 ConfigMap 网络策略名称 RFC 1123 标签名 【长度63】 # 某些资源类型需要其名称遵循 RFC 1123 所定义的 DNS 标签标准。也就是命名必须满足如下规则：\n最多 63 个字符 只能包含小写字母、数字，以及 \u0026lsquo;-\u0026rsquo; 必须以字母数字开头 必须以字母数字结尾 相关资源类型：\n服务名称 命名空间名称 RFC 1035 标签名【长度63】 # 某些资源类型需要其名称遵循 RFC 1035 所定义的 DNS 标签标准。也就是命名必须满足如下规则：\n最多 63 个字符 只能包含小写字母、数字，以及 \u0026lsquo;-\u0026rsquo; 必须以字母开头 必须以字母数字结尾 相关资源类型：\n路径分段名称（Path Segment Names） # 某些资源类型要求名称能被安全地用作路径中的片段。 换句话说，其名称不能是 .、..，也不可以包含 / 或 % 这些字符。\n相关资源类型： Role、ClusterRole、RoleBinding、ClusterRoleBinding\n其他 # 镜像名称 # 参考 https://kubernetes.io/zh/docs/concepts/containers/images/#image-names\n标签【label】【最长381=253+1+63+1+63】 # 参考 标签和选择算符 | Kubernetes\n标签合法格式:[前缀/]标签名称:[标签值]\n前缀【正则表达式同 DNS子域名】是可选的。如果指定，前缀必须是 DNS 子域：由点（.）分隔的一系列 DNS 标签，总共不超过 253 个字符， 后跟斜杠（/）\n名称【正则：^([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9]$】是必需的，必须小于等于 63 个字符，以字母数字字符（[a-z0-9A-Z]）开头和结尾， 带有破折号（-），下划线（_），点（ .）和之间的字母数字。\n有效标签值：【正则表达式同标签名称】\n必须为 63 个字符或更少（可以为空） 除非标签值为空，必须以字母数字字符（[a-z0-9A-Z]）开头和结尾 包含破折号（-）、下划线（_）、点（.）和字母或数字 应用名称【Release.name】【长度53】 # 长度限制为 53 个字符，正则表达式为：\n^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$ 提示: 由于DNS系统的限制，name:字段长度限制为63个字符。因此发布名称限制为53个字符。 Kubernetes 1.3及更早版本限制为24个字符 (名称长度是14个字符)。\n提示： 向最终用户对象添加标签的自动系统组件（例如 kube-scheduler、kube-controller-manager、 kube-apiserver、kubectl 或其他第三方自动化工具）必须指定前缀。\n注解【Annotations】【key最长317=253+1+63，value无限制】 # 参考： 注解 | Kubernetes 语法和字符集\n注解合法格式:[前缀/]标签名称:[标签值]\n前缀是可选的。如果指定，前缀必须是 DNS 子域：由点（.）分隔的一系列 DNS 标签，总共不超过 253 个字符， 后跟斜杠（/） 名称是必需的，必须小于等于 63 个字符，以字母数字字符（[a-z0-9A-Z]）开头和结尾， 带有破折号（-），下划线（_），点（ .）和之间的字母数字。 提示： 由系统组件添加的注解 （例如，kube-scheduler，kube-controller-manager，kube-apiserver，kubectl 或其他第三方组件），必须为终端用户添加注解前缀。\n端口名称【最长15】 # 最多 15 个字符 只能包含小写字母、数字，以及 \u0026lsquo;-\u0026rsquo;，且\u0026rsquo;-\u0026lsquo;不能连续 必须以字母数字开头 必须以字母数字结尾 "},{"id":2,"href":"/post/go-code-review-comments/","title":"Go Code Review Comments","section":"Posts","content":"原文地址：https://github.com/golang/go/wiki/CodeReviewComments\nGofmt 声明的注释应该是句子 Contexts 复制 Crypto Rand 声明空数组 文档注释 不要使用panic 错误字符串 例子 Goroutine 生命周期 处理错误 导入 作为空的导入 作为句点的导入 带内错误 缩进错误处理流 首字母缩写 Interfaces Line Length 混合大小写(驼峰) 具名返回参数 Naked Returns Package Comments Package Names Pass Values Receiver Names Receiver Type Synchronous Functions 有意义的测试错误信息 变量名 Gofmt # 在你的代码上运行gofmt可以解决大多数固定的代码风格问题。几乎所有的Go代码都在使用 gofmt。本文档的其他部分会讨论非固定格式的代码风格问题。\n你也可以使用goimports, 它是 gofmt 的超集，可以根据需要添加或删除 import 行。\n注释应该是句子 # 参见 https://golang.org/doc/effective_go.html#commentary 。针对声明的代码注释应该是完整的句子，即使它看起来有些多余。 这样你生成 godoc 文档可读性更好。注释应该以所描述事物的名称开始，并以句号结束:\n1 2 3 4 5 // Request represents a request to run a command. type Request struct { ... // Encode writes the JSON encoding of req to w. func Encode(w io.Writer, req *Request) { ... Contexts # context.Context 类型的 Value 可以携带跨越API或处理逻辑边界的安全凭据，追踪信息，截止日期或取消信号。在 Go 程序里，Context 显式地在整个函数调用链中传递，从接受 RPC 或者 HTTP 调用，一直到对外的 RPC 或者 HTTP 调用。\n大多数使用Context的函数，都应该把它作为第一个参数:\n1 func F(ctx context.Context, /* other arguments */) {} A function that is never request-specific may use context.Background(), but err on the side of passing a Context even if you think you don\u0026rsquo;t need to. The default case is to pass a Context; only use context.Background() directly if you have a good reason why the alternative is a mistake.\nDon\u0026rsquo;t add a Context member to a struct type; instead add a ctx parameter to each method on that type that needs to pass it along. The one exception is for methods whose signature must match an interface in the standard library or in a third party library.\nDon\u0026rsquo;t create custom Context types or use interfaces other than Context in function signatures.\nIf you have application data to pass around, put it in a parameter, in the receiver, in globals, or, if it truly belongs there, in a Context value.\n上下文是不可变的，所以可以放心把同一个ctx传递给多个调用，如果这些调用共享截止时间，取消信号，凭证，追踪信息等。\n复制 # 为了避免意外的别名，在从另一个 package 复制结构时，要尤其小心。 例如，bytes.Buffer 类型包含一个 []byte 切片。如果你复制一个 Buffer， 副本中的切片只是原始数组的别名，从而导致后续方法调用可能会有意外的效果。 一般来说，如果类型 T 的方法，关联的是它的指针类型 *T ，那么不要复制 T 的值。\nCrypto Rand # 不要使用 math/rand 来生成密钥，即使是一次性的密钥。 在没有种子的情况下，生成的密钥是完全可以预测的。使用 time.Nanoseconds() 作为种子，也只带来少量的熵。你应该使用 crypto/rand 的 Reader， 如果需要的是文本，可以打印为十六进制或base64:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import ( \u0026#34;crypto/rand\u0026#34; // \u0026#34;encoding/base64\u0026#34; // \u0026#34;encoding/hex\u0026#34; \u0026#34;fmt\u0026#34; ) func Key() string { buf := make([]byte, 16) _, err := rand.Read(buf) if err != nil { panic(err) // out of randomness, should never happen } return fmt.Sprintf(\u0026#34;%x\u0026#34;, buf) // or hex.EncodeToString(buf) // or base64.StdEncoding.EncodeToString(buf) } 声明空切片 # 当你创建空切片时推荐使用：\n1 var t []string 而不是\n1 t := []string{} 前者是一个值为nil的切片。后者只是长度为零，但不是nil。他们在功能上是完全相同的。他们的 len and cap都是零，但是nil切片是更加推荐的方式。\n请注意，在有些特殊情况，更推荐使用不为nil，但长度为零但切片，例如编码 JSON对象但时候（一个nil切片被编码成null，但是[]string{}被比编码成JSON数组[]）。\n在设计接口时，避免区分nil片和非nil、零长度的片，因为这可能会导致微妙的编程错误。\nWhen designing interfaces, avoid making a distinction between a nil slice and a non-nil, zero-length slice, as this can lead to subtle programming errors.\nGo中关于nil的更多讨论可以看一下 Francesc Campoy 的视频 Understanding Nil.\n文档注释 # 所有顶级的、可导出的名称，都应该有文档注释，重要的未导出类型或函数声明也应该如此。有关注释约定的更多信息，请参见https://golang.org/doc/effective_go.html#commentary。\n不要使用panic # 参见 https://golang.org/doc/effective_go.html#errors. 对于正常的错误处理，不要使用panic。使用错误和多个返回值。\n错误字符串 # 错误字符串不应该大写(除非以专有名词或首字母缩写开头)，也不应该以标点符号结尾，因为它们通常在其他上下文后面打印。也就是说，使用\n1 fmt.Errorf(\u0026#34;something bad\u0026#34;) 而不是\n1 fmt.Errorf(\u0026#34;Something bad.\u0026#34;) 这样\n1 log.Printf(\u0026#34;Reading %s: %v\u0026#34;, filename, err) 的输出才不会出现大写字母。不过这不适用于日志记录，日志记录是隐式面向行的，不会在其他消息中合并。\n例子 # 添加新的 package 时，同时添加一些使用示例，这些示例应该是可运行的，或者一个可以演示的，包含了完整调用过程的测试用例。更多内容参见 testable Example() functions.\nGoroutine 生命周期 # 当你起一个 goroutine 时，你要清楚它是否需要退出，或者什么时候退出。\nGoroutines can leak by blocking on channel sends or receives: the garbage collector will not terminate a goroutine even if the channels it is blocked on are unreachable.\nEven when goroutines do not leak, leaving them in-flight when they are no longer needed can cause other subtle and hard-to-diagnose problems. Sends on closed channels panic. Modifying still-in-use inputs \u0026ldquo;after the result isn\u0026rsquo;t needed\u0026rdquo; can still lead to data races. And leaving goroutines in-flight for arbitrarily long can lead to unpredictable memory usage.\n尽量保持并发代码足够简单，这样goroutine的生存期就会很明显。如果这是不可行的，请写好文档，记录goroutines 何时退出以及为什么退出。\n处理错误 # 参见 https://golang.org/doc/effective_go.html#errors. 不要使用 _ 变量丢弃错误。如果函数返回一个错误，明确地检查错误，确保函数执行成功。要么处理错误，要么向上一级返回它，又或者，确定是一个无法处理的异常的话，选择 panic。\n导入 # 不要重命名导入的包名，除非为了避免包名冲突；好的包名不应该需要重命名。包名冲突时，优先重命名最局部的包名，或者项目特有的导入包。\n多行导入使用空行对他们分组。标准库的包总是放在第一个组。\n1 2 3 4 5 6 7 8 9 10 11 12 13 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;hash/adler32\u0026#34; \u0026#34;os\u0026#34; \u0026#34;appengine/foo\u0026#34; \u0026#34;appengine/user\u0026#34; \u0026#34;github.com/foo/bar\u0026#34; \u0026#34;rsc.io/goversion/version\u0026#34; ) goimports 可以自动为你做好分组排序。\n作为空的导入 # 仅因其副作用而导入的包(使用语法 import _ \u0026quot;pkg\u0026quot; )应仅在程序的 main 包或测试包导入。\n作为句点的导入 # 在写测试代码的时候，由于循环依赖的问题，导致包不能导入，这是导入成句点这种形式可能会有用：\n1 2 3 4 5 6 package foo_test import ( \u0026#34;bar/testutil\u0026#34; // also imports \u0026#34;foo\u0026#34; . \u0026#34;foo\u0026#34; ) 在这种情况下，这个测试文件不能在 foo 包中，因为它导入了 bar/testutil，而 bar/testutil 又导入了 foo。所以我们使用 import . 的形式，让文件假装是 foo 包的一部分，即使它不是。除了这一种情况，不要在你的程序中使用 import .。它使程序更难阅读，因为不清楚像 Quux 这样的名称是当前包中的顶级标识符还是导入包中的顶级标识符。\n带内错误 # 在C和其他类似语言中，经常让函数返回 -1 表示信号错误，或者返回 null 表示没有结果：\n1 2 3 4 5 // Lookup 返回key对应的value，如果没有的话则返回 \u0026#34;\u0026#34; func Lookup(key string) string // Failing to check a for an in-band error value can lead to bugs: Parse(Lookup(key)) // returns \u0026#34;parse failure for value\u0026#34; instead of \u0026#34;no value for key\u0026#34; Go 的函数可以返回多个值，这是一个更好的方案。\nInstead of requiring clients to check for an in-band error value, a function should return an additional value to indicate whether its other return values are valid. This return value may be an error, or a boolean when no explanation is needed. It should be the final return value.\n1 2 // Lookup returns the value for key or ok=false if there is no mapping for key. func Lookup(key string) (value string, ok bool) 这防止了调用者错误地使用调用结果：\n1 Parse(Lookup(key)) // 编译错误 并鼓励更健壮和可读的代码: And encourages more robust and readable code:\n1 2 3 4 5 value, ok := Lookup(key) if !ok { return fmt.Errorf(\u0026#34;no value for %q\u0026#34;, key) } return Parse(value) 该规则适用于可导出的函数，对于不可到处的函数，也是有用的。\n如果 nil， \u0026ldquo;\u0026quot;， 0 或者 -1 是有意义的返回结果，也就是说，函数的调用者不需要将其与其他值区别处理，那么函数直接返回这些值也是可以的。\nGo 的函数标准库里，比如 strings 包，里面就有一些函数，直接返回了带内错误。 This greatly simplifies string-manipulation code at the cost of requiring more diligence from the programmer.通常，Go代码应该返回额外的错误值。\n缩进错误处理流 # 尽量将常规代码路径缩进到最小，并缩进错误处理，先处理它。通过允许可视化地快速扫描正常路径，提高了代码的可读性。例如，不要这样写:\n1 2 3 4 5 if err != nil { // error handling } else { // normal code } 而应该写成:\n1 2 3 4 5 if err != nil { // error handling return // or continue, etc. } // normal code 如果\u0026rsquo; If \u0026lsquo;语句有一个初始化语句，例如:\n1 2 3 4 5 6 if x, err := f(); err != nil { // error handling return } else { // use x } 这可能需要将短变量声明移到单独的行中，这样缩进的错误处理代码后面的正常代码逻辑才能使用变量 x:\n1 2 3 4 5 6 x, err := f() if err != nil { // error handling return } // use x 首字母缩写 # 名字中的单词是缩写或首字母缩写(例如:“URL”或“NATO”)是，大小写要保持一致。例如，\u0026ldquo;URL\u0026rdquo; 应该写成 \u0026ldquo;URL\u0026rdquo; 或者 \u0026ldquo;url\u0026rdquo;，而不要写成\u0026quot;Url\u0026rdquo;。作为名字的一部分时，写作 \u0026ldquo;urlPony\u0026rdquo;，或者 \u0026ldquo;URLPony\u0026rdquo;. 又例如，ServeHttp 应该写成 ServeHTTP。对于具有多个初始化“单词”的标识符，可以使用例如“xmlHTTPRequest”或“xmlHTTPRequest”。\n当“ID”是“identifier”的缩写时，这条规则也适用，所以写成“appID”，而不是“appId”。\nprotocol buffer 编译器生成的代码不受此规则约束。人类编写的代码比机器编写的代码有更高的标准。\nInterfaces # Go接口通常属于使用 接口类型，而不是实现这些值的包。的 实现包应该返回具体的(通常是指针或结构) 类型:这样，新的方法可以添加到实现中而不需要 需要广泛的重构。\nGo interfaces generally belong in the package that uses values of the interface type, not the package that implements those values. The implementing package should return concrete (usually pointer or struct) types: that way, new methods can be added to implementations without requiring extensive refactoring.\nDo not define interfaces on the implementor side of an API \u0026ldquo;for mocking\u0026rdquo;; instead, design the API so that it can be tested using the public API of the real implementation.\nDo not define interfaces before they are used: without a realistic example of usage, it is too difficult to see whether an interface is even necessary, let alone what methods it ought to contain.\n1 2 3 4 5 package consumer // consumer.go type Thinger interface { Thing() bool } func Foo(t Thinger) string { … } 1 2 3 4 5 6 package consumer // consumer_test.go type fakeThinger struct{ … } func (t fakeThinger) Thing() bool { … } … if Foo(fakeThinger{…}) == \u0026#34;x\u0026#34; { … } 1 2 3 4 5 6 7 8 9 // DO NOT DO IT!!! package producer type Thinger interface { Thing() bool } type defaultThinger struct{ … } func (t defaultThinger) Thing() bool { … } func NewThinger() Thinger { return defaultThinger{ … } } Instead return a concrete type and let the consumer mock the producer implementation.\n1 2 3 4 5 6 package producer type Thinger struct{ … } func (t Thinger) Thing() bool { … } func NewThinger() Thinger { return Thinger{ … } } Line Length # There is no rigid line length limit in Go code, but avoid uncomfortably long lines. Similarly, don\u0026rsquo;t add line breaks to keep lines short when they are more readable long\u0026ndash;for example, if they are repetitive.\nMost of the time when people wrap lines \u0026ldquo;unnaturally\u0026rdquo; (in the middle of function calls or function declarations, more or less, say, though some exceptions are around), the wrapping would be unnecessary if they had a reasonable number of parameters and reasonably short variable names. Long lines seem to go with long names, and getting rid of the long names helps a lot.\nIn other words, break lines because of the semantics of what you\u0026rsquo;re writing (as a general rule) and not because of the length of the line. If you find that this produces lines that are too long, then change the names or the semantics and you\u0026rsquo;ll probably get a good result.\nThis is, actually, exactly the same advice about how long a function should be. There\u0026rsquo;s no rule \u0026ldquo;never have a function more than N lines long\u0026rdquo;, but there is definitely such a thing as too long of a function, and of too stuttery tiny functions, and the solution is to change where the function boundaries are, not to start counting lines.\n混合大小写(驼峰) # 参见 https://golang.org/doc/effective_go.html#mixed-caps. 这可能与其他语言的约定不同，比如不可导出的常量应该命名为 maxLength，而不是 MaxLength 或 MAX_LENGTH.\nAlso see Initialisms.\n具名返回参数 # Consider what it will look like in godoc. Named result parameters like:\n1 2 func (n *Node) Parent1() (node *Node) {} func (n *Node) Parent2() (node *Node, err error) {} will stutter in godoc; better to use:\n1 2 func (n *Node) Parent1() *Node {} func (n *Node) Parent2() (*Node, error) {} On the other hand, if a function returns two or three parameters of the same type, or if the meaning of a result isn\u0026rsquo;t clear from context, adding names may be useful in some contexts. Don\u0026rsquo;t name result parameters just to avoid declaring a var inside the function; that trades off a minor implementation brevity at the cost of unnecessary API verbosity.\n1 func (f *Foo) Location() (float64, float64, error) is less clear than:\n1 2 3 // Location returns f\u0026#39;s latitude and longitude. // Negative values mean south and west, respectively. func (f *Foo) Location() (lat, long float64, err error) Naked returns are okay if the function is a handful of lines. Once it\u0026rsquo;s a medium sized function, be explicit with your return values. Corollary: it\u0026rsquo;s not worth it to name result parameters just because it enables you to use naked returns. Clarity of docs is always more important than saving a line or two in your function.\nFinally, in some cases you need to name a result parameter in order to change it in a deferred closure. That is always OK.\nNaked Returns # 参见 具名返回参数.\n包注释 # Package comments, like all comments to be presented by godoc, must appear adjacent to the package clause, with no blank line.\n1 2 // Package math provides basic constants and mathematical functions. package math 1 2 3 4 5 6 /* Package template implements data-driven templates for generating textual output such as HTML. .... */ package template For \u0026ldquo;package main\u0026rdquo; comments, other styles of comment are fine after the binary name (and it may be capitalized if it comes first), For example, for a package main in the directory seedgen you could write:\n1 2 // Binary seedgen ... package main or\n1 2 // Command seedgen ... package main or\n1 2 // Program seedgen ... package main or\n1 2 // The seedgen command ... package main or\n1 2 // The seedgen program ... package main or\n1 2 // Seedgen .. package main These are examples, and sensible variants of these are acceptable.\nNote that starting the sentence with a lower-case word is not among the acceptable options for package comments, as these are publicly-visible and should be written in proper English, including capitalizing the first word of the sentence. When the binary name is the first word, capitalizing it is required even though it does not strictly match the spelling of the command-line invocation.\nSee https://golang.org/doc/effective_go.html#commentary for more information about commentary conventions.\nPackage Names # All references to names in your package will be done using the package name, so you can omit that name from the identifiers. For example, if you are in package chubby, you don\u0026rsquo;t need type ChubbyFile, which clients will write as chubby.ChubbyFile. Instead, name the type File, which clients will write as chubby.File. Avoid meaningless package names like util, common, misc, api, types, and interfaces. See http://golang.org/doc/effective_go.html#package-names and http://blog.golang.org/package-names for more.\nPass Values # Don\u0026rsquo;t pass pointers as function arguments just to save a few bytes. If a function refers to its argument x only as *x throughout, then the argument shouldn\u0026rsquo;t be a pointer. Common instances of this include passing a pointer to a string (*string) or a pointer to an interface value (*io.Reader). In both cases the value itself is a fixed size and can be passed directly. This advice does not apply to large structs, or even small structs that might grow.\nReceiver Names # The name of a method\u0026rsquo;s receiver should be a reflection of its identity; often a one or two letter abbreviation of its type suffices (such as \u0026ldquo;c\u0026rdquo; or \u0026ldquo;cl\u0026rdquo; for \u0026ldquo;Client\u0026rdquo;). Don\u0026rsquo;t use generic names such as \u0026ldquo;me\u0026rdquo;, \u0026ldquo;this\u0026rdquo; or \u0026ldquo;self\u0026rdquo;, identifiers typical of object-oriented languages that gives the method a special meaning. In Go, the receiver of a method is just another parameter and therefore, should be named accordingly. The name need not be as descriptive as that of a method argument, as its role is obvious and serves no documentary purpose. It can be very short as it will appear on almost every line of every method of the type; familiarity admits brevity. Be consistent, too: if you call the receiver \u0026ldquo;c\u0026rdquo; in one method, don\u0026rsquo;t call it \u0026ldquo;cl\u0026rdquo; in another.\nReceiver Type # Choosing whether to use a value or pointer receiver on methods can be difficult, especially to new Go programmers. If in doubt, use a pointer, but there are times when a value receiver makes sense, usually for reasons of efficiency, such as for small unchanging structs or values of basic type. Some useful guidelines:\nIf the receiver is a map, func or chan, don\u0026rsquo;t use a pointer to them. If the receiver is a slice and the method doesn\u0026rsquo;t reslice or reallocate the slice, don\u0026rsquo;t use a pointer to it. If the method needs to mutate the receiver, the receiver must be a pointer. If the receiver is a struct that contains a sync.Mutex or similar synchronizing field, the receiver must be a pointer to avoid copying. If the receiver is a large struct or array, a pointer receiver is more efficient. How large is large? Assume it\u0026rsquo;s equivalent to passing all its elements as arguments to the method. If that feels too large, it\u0026rsquo;s also too large for the receiver. Can function or methods, either concurrently or when called from this method, be mutating the receiver? A value type creates a copy of the receiver when the method is invoked, so outside updates will not be applied to this receiver. If changes must be visible in the original receiver, the receiver must be a pointer. If the receiver is a struct, array or slice and any of its elements is a pointer to something that might be mutating, prefer a pointer receiver, as it will make the intention more clear to the reader. If the receiver is a small array or struct that is naturally a value type (for instance, something like the time.Time type), with no mutable fields and no pointers, or is just a simple basic type such as int or string, a value receiver makes sense. A value receiver can reduce the amount of garbage that can be generated; if a value is passed to a value method, an on-stack copy can be used instead of allocating on the heap. (The compiler tries to be smart about avoiding this allocation, but it can\u0026rsquo;t always succeed.) Don\u0026rsquo;t choose a value receiver type for this reason without profiling first. Don\u0026rsquo;t mix receiver types. Choose either pointers or struct types for all available methods. Finally, when in doubt, use a pointer receiver. 同步函数 # 更推荐使用同步函数，而非异步函数。同步函数是那些直接返回结果，或者在返回结果之前，完成所有回调或信道操作的函数。\nSynchronous functions keep goroutines localized within a call, making it easier to reason about their lifetimes and avoid leaks and data races. They\u0026rsquo;re also easier to test: the caller can pass an input and check the output without the need for polling or synchronization.\n如果调用者需要更高的并发性，他们可以在其他 goroutine 中来调用该函数。 But it is quite difficult - sometimes impossible - to remove unnecessary concurrency at the caller side.\n有意义的测试错误信息 # 测试代码失败的时候，应该给出有用的信息，说明出了什么问题，输入是什么，期望得到什么，预期得到什么。你可能会写一些 assertFoo 工具函数，不过也要确保这些函数输出有用的错误信息。写测试代码时，要假定调试这些测试代码的人不是你，也不是你的团队成员。一个典型的Go测试失败如下:\n1 2 3 if got != tt.want { t.Errorf(\u0026#34;Foo(%q) = %d; want %d\u0026#34;, tt.in, got, tt.want) // or Fatalf, if test can\u0026#39;t test anything more past this point } 注意这里的顺序是 actual != expected, 输出的错误信息也是这个顺序。有些测试框架推荐相反的顺序：0 != x, \u0026quot;expected 0, got x\u0026quot;, 等等。Go 里面不这样写。\n如果测试需要大量输入，那么你可能需要编写表格驱动的测试。\n如果一个测试辅助函数需要调用多次，多次调用只是传不同参数，那么为了消除错误输出信息的歧义，方便运行测试的人确定测试失败位置，一种常见的方式，是用不同的 TestFoo 函数包装每次调用，并根据不同的输入命名对应的测试函数:\n1 2 3 4 5 6 7 func TestSingleValue(t *testing.T) { testHelper(t, []int{80}) } func TestNoValues(t *testing.T) { testHelper(t, []int{}) } 无论如何，向调试您代码的人提供有用的消息，这个责任都在你身上。\n变量名 # \u0008变量名称应该尽可能的短。尤其是只在小范围使用短局部变量，例如 c 替换 lineCount。 i 替换 sliceIndex\n基本规则：使用变量名的地方距离声明它的地方越远，变量名描述的越具体。 对于方法的 receiver，一两个字母就够了。常见的变量，例如循环的下标和接收值的变量名，一个字母就够了（i, r）。其他不常用的或者全局变量，则需要描述的更具体一些。\n"},{"id":3,"href":"/post/mysql-development-specification/","title":"MySQL 开发规范","section":"Posts","content":" 基础规范 建表规约 索引规约 SQL规约 字段规约 基础规范 # 必须使用InnoDB存储引擎 支持事务、行级锁、并发性能更好、CPU及内存缓存页优化使得资源利用率更高\n必须使用UTF8字符集 万国码，无需转码，无乱码风险，节省空间。\n数据表、数据字段必须加入中文注释 时间久了，没人记得字段的作用，还得去看代码\n禁止使用存储过程、视图、触发器、Event 解读：高并发大数据的互联网业务，架构设计思路是“解放数据库CPU，将计算转移到服务层”，并发量大的情况下，这些功能很可能将数据库拖死， 业务逻辑放到服务层具备更好的扩展性，能够轻易实现“增机器就加性能”。数据库擅长存储与索引，CPU 计算放在应用中实现\n禁止存储大文件或者大照片 大文件和照片存储在文件系统或OSS，数据库里存URI\n建表规约 # -【强制】表达是与否概念的字段，必须使用 is_xxx 的方式命名\n正例：is_delete , 数据类型是 unsigned tinyint ( 1表示是，0表示否)。 说明:任何字段如果为非负数，必须是 unsigned。\n-【强制】表名、字段名必须使用小写字母或数字;禁止出现数字开头，禁止两个下划线中间只 出现数字。数据库字段名的修改代价很大，因为无法进行预发布，所以字段名称需要慎重考虑。\n正例：getter_admin，task_config，level3_name 反例：GetterAdmin，taskConfig，level_3_name。\n-【强制】表名不使用复数名词。 说明:表名应该仅仅表示表里面的实体内容，不应该表示实体数量，对应于 DO 类名也是单数 形式，符合表达习惯。\n-【强制】禁用保留字，如 desc、range、match、delayed 等，请参考 MySQL 官方保留字。\n-【强制】唯一索引名为uniq_字段名;普通索引名则为 idx_字段名。\n说明:uniq_ 即 unique key;idx_ 即 index 的简称。\n-【强制】小数类型为 decimal，禁止使用 float 和 double。\n说明:float 和 double 在存储的时候，存在精度损失的问题，很可能在值的比较时，得到不 正确的结果。如果存储的数据范围超过 decimal 的范围，建议将数据拆成整数和小数分开存储。\n-【强制】varchar 是可变长字符串，不预先分配存储空间，长度不要超过 5000，如果存储长 度大于此值，定义字段类型为 text，独立出来一张表，用主键来对应，避免影响其它字段索引效率。\n-【强制】表必备三字段:id, create_time, modified_time。 说明:其中id必为主键，类型为unsigned bigint、单表时自增、步长为1。create_time为 date_time 类型。modified_time为timestamp，extra值为：on update CURRENT_TIMESTAMP 默认值为：CURRENT_TIMESTAMP\n-【推荐】表的命名最好是加上“业务名称_表的作用”。\n正例：tiger_task / tiger_reader / mpp_config。\n-【推荐】库名与应用名称尽量一致。\n-【推荐】如果修改字段含义或对字段表示的状态追加时，需要及时更新字段注释。\n-【推荐】字段允许适当冗余，以提高性能，但是必须考虑数据同步的情况。 冗余字段应遵循:\n1)不是频繁修改的字段。\n2)不是 varchar 超长字段，更不能是 text 字段。 正例:商品类目名称使用频率高，字段长度短，名称基本一成不变，可在相关联的表中冗余存 储类目名称，避免关联查询。\n-【推荐】单表行数超过 500 万行或者单表容量超过 2GB，才推荐进行分库分表。\n说明:如果预计三年后的数据量根本达不到这个级别，请不要在创建表时就分库分表。\n-【参考】合适的字符存储长度，不但节约数据库表空间、节约索引存储，更重要的是提升检索速度。\n正例：人的年龄用 unsigned tinyint(表示范围 0-255，人的寿命不会超过 255 岁);\n海龟 就必须是 smallint，但如果是太阳的年龄，就必须是 int;如果是所有恒星的年龄都加起来， 那么就必须使用 bigint。\n索引规约 # -【强制】业务上具有唯一特性的字段，即使是组合字段，也必须建成唯一索引。\n说明:不要以为唯一索引影响了 insert 速度，这个速度损耗可以忽略，但提高查找速度是明显的;\n另外，即使在应用层做了非常完善的校验和控制，只要没有唯一索引，根据墨菲定律， 必然有脏数据产生。\n-【强制】 超过三个表禁止 join。需要 join 的字段，数据类型保持绝对一致;多表关联查询 时，保证被关联的字段需要有索引。\n说明:即使双表 join 也要注意表索引、SQL 性能。\n【强制】在 varchar 字段上建立索引时，必须指定索引长度，没必要对全字段建立索引，根据 实际文本区分度决定索引长度。\n说明:索引的长度与区分度是一对矛盾体，一般对字符串类型数据，长度为 20 的索引，区分 度会高达 90%以上，可以使用 count(distinct left(列名, 索引长度))/count(*)的区分度 来确定。\n-【强制】页面搜索严禁左模糊或者全模糊，如果需要请走搜索引擎来解决。\n说明:索引文件具有 B-Tree 的最左前缀匹配特性，如果左边的值未确定，那么无法使用此索 引。\n-【推荐】如果有 order by 的场景，请注意利用索引的有序性。order by 最后的字段是组合 索引的一部分，并且放在索引组合顺序的最后，避免出现 file_sort 的情况，影响查询性能。\n正例：where a=? and b=? order by c; 索引:a_b_c\n反例：索引中有范围查找，那么索引有序性无法利用，如:WHERE a\u0026gt;10 ORDER BY b; 索引 a_b 无法排序。\n-单表索引建议控制在5个以内\n单索引字段数不允许超过5个,解读：字段超过5个时，实际已经起不到有效过滤数据的作用了 。\n-禁止在更新十分频繁、区分度不高的属性上建立索引\n解读：\na）更新会变更B+树，更新频繁的字段建立索引会大大降低数据库性能\nb）“性别”这种区分度不大的属性，建立索引是没有什么意义的，不能有效过滤数据，性能与全表扫描类似\n-建立组合索引，必须把区分度高的字段放在前面\n解读：能够更加有效的过滤数据\n-【参考】创建索引时避免有如下极端误解: 1)误认为一个查询就需要建一个索引。 2)误认为索引会消耗空间、严重拖慢更新和新增速度。 3)误认为唯一索引一律需要在应用层通过“先查后插”方式解决。\n-【推荐】利用覆盖索引来进行查询操作，来避免回表操作。\n说明:如果一本书需要知道第 11 章是什么标题，会翻开第 11 章对应的那一页吗?目录浏览 一下就好，这个目录就是起到覆盖索引的作用。\n正例：能够建立索引的种类:主键索引、唯一索引、普通索引，而覆盖索引是一种查询的一种 效果，用explain的结果，extra列会出现:using index。\n-【推荐】利用延迟关联或者子查询优化超多分页场景。\n说明:MySQL 并不是跳过 offset 行，而是取 offset+N 行，然后返回放弃前 offset 行，返回 N 行，那当 offset 特别大的时候，效率就非常的低下，要么控制返回的总页数，要么对超过 特定阈值的页数进行 SQL 改写。\n正例：先快速定位需要获取的 id 段，然后再关联:\n1 SELECT a.* FROM table_1 a join (select id from table_1 where condition LIMIT 100000,20 ) b where a.id=b.id -【推荐】SQL 性能优化的目标:至少要达到 range 级别，要求是 ref 级别，如果可以是 consts 最好。\n说明:\n1)consts 单表中最多只有一个匹配行(主键或者唯一索引)，在优化阶段即可读取到数据。 2)ref 指的是使用普通的索引(normal index)。 3)range 对索引进行范围检索。\n反例：explain 表的结果，type=index，索引物理文件全扫描，速度非常慢，这个 index 级 别比较 range 还低，与全表扫描是小巫见大巫。\n-【推荐】建组合索引的时候，区分度最高的在最左边。 正例：如果 where a=? and b=? ，a 列的几乎接近于唯一值，那么只需要单建 idx_a 索引即 可。\n说明:存在非等号和等号混合判断条件时，在建索引时，请把等号条件的列前置。如:where a\u0026gt;? and b=? 那么即使 a 的区分度更高，也必须把 b 放在索引的最前列。\nSQL 规约 # -【强制】不要使用 count(列名)或 count(常量)来替代 count(*)，count(*)就是 SQL92 定义 的标准统计行数的语法，跟数据库无关，跟 NULL 和非 NULL 无关。\n说明:count(*)会统计值为 NULL 的行，而 count(列名)不会统计此列为 NULL 值的行。\n-【强制】count(distinct col) 计算该列除 NULL 之外的不重复数量。注意 count(distinct col1, col2) 如果其中一列全为NULL，那么即使另一列有不同的值，也返回为0。\n-【强制】当某一列的值全是 NULL 时，count(col)的返回结果为 0，但 sum(col)的返回结果为 NULL，因此使用 sum()时需注意 NPE 问题。\n正例:可以使用如下方式来避免sum的NPE问题:\n1 SELECT IF(ISNULL(SUM(g)),0,SUM(g)) FROM table; -【强制】使用 ISNULL()来判断是否为 NULL 值。注意:NULL 与任何值的直接比较都为 NULL。 说明:\nNULL\u0026lt;\u0026gt;NULL的返回结果是NULL，而不是false。 2) NULL=NULL的返回结果是NULL，而不是true。 NULL\u0026lt;\u0026gt;1的返回结果是NULL，而不是true。 -【强制】 在代码中写分页查询逻辑时，若 count 为 0 应直接返回，避免执行后面的分页语句。\n-【强制】不得使用外键与级联，一切外键概念必须在应用层解决。\n说明:(概念解释)学生表中的 student_id 是主键，那么成绩表中的 student_id 则为外键。 如果更新学生表中的 student_id，同时触发成绩表中的 student_id 更新，则为级联更新。 外键与级联更新适用于单机低并发，不适合分布式、高并发集群;级联更新是强阻塞，存在数 据库更新风暴的风险;外键影响数据库的插入速度。\n-【强制】禁止使用存储过程，存储过程难以调试和扩展，更没有移植性。\n-【强制】数据订正时，删除和修改记录时，要先 select，避免出现误删除，确认无误才能执行更新语句。\n-【推荐】in 操作能避免则避免，若实在避免不了，需要仔细评估 in 后边的集合元素数量，控制在 1000 个之内。\n-【参考】如果有全球化需要，所有的字符存储与表示，均以 utf-8 编码，那么字符计数方法 注意:\n说明:\n1 2 SELECT LENGTH(\u0026#34;轻松工作\u0026#34;); 返回为12 SELECT CHARACTER_LENGTH(\u0026#34;轻松工作\u0026#34;); 返回为4 如果要使用表情，那么使用 utfmb4 来进行存储，注意它与 utf-8 编码的区别。\n-【参考】TRUNCATE TABLE 比 DELETE 速度快，且使用的系统和事务日志资源少，但 TRUNCATE 无事务且不触发 trigger，有可能造成事故，故不建议在开发代码中使用此语句。 说明:TRUNCATE TABLE 在功能上与不带 WHERE 子句的 DELETE 语句相同。\n字段规约 # -必须把字段定义为NOT NULL并且提供默认值\n解读：\na）null的列使索引/索引统计/值比较都更加复杂，对MySQL来说更难优化。\nb）null 这种类型MySQL内部需要进行特殊处理，增加数据库处理记录的复杂性；同等条件下，表中有较多空字段的时候，数据库的处理性能会降低很多。\nc）null值需要更多的存储空，无论是表还是索引中每行中的null的列都需要额外的空间来标识\nd）对null 的处理时候，只能采用is null或is not null，而不能采用=、in、\u0026lt;、\u0026lt;\u0026gt;、!=、not in这些操作符号。如：where name!=’shenjian’，如果存在name为null值的记录，查询结果就不会包含name为null值的记录\n-禁止使用TEXT、BLOB类型\n解读：会浪费更多的磁盘和内存空间，非必要的大量的大字段查询会淘汰掉热数据，导致内存命中率急剧降低，影响数据库性能\n-禁止使用小数存储货币\n解读：使用整数吧，小数容易导致钱对不上\n-必须使用varchar(20)存储手机号\n解读：\na）涉及到区号或者国家代号，可能出现+-()\nb）手机号会去做数学运算么？\nc）varchar可以支持模糊查询，例如：like“138%”\n-禁止使用ENUM，可使用TINYINT代替\n解读：\na）增加新的ENUM值要做DDL操作\nb）ENUM的内部实际存储就是整数\n"},{"id":4,"href":"/post/transaction/","title":"MySQL 事务","section":"Posts","content":"\n事务的特性 事务隔离级别 ACID vs CAP 使用事务 总结 事务的特性 # 所谓事务，它是一个操作序列，这些操作要么都执行，要么都不执行，它是一个不可分割的工作单位。\nAtomicity（原子性） 原子性是指事务是一个不可再分割的工作单位，事务中的操作要么都发生，要么都不发生。\nConsistency（一致性） 一致性是指在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏。这是说数据库事务不能破坏关系数据的完整性以及业务逻辑上的一致性。\nIsolation（隔离性） 多个事务并发访问时，事务之间是隔离的，一个事务不应该影响其它事务运行效果。\n这指的是在并发环境中，当不同的事务同时操纵相同的数据时，每个事务都有各自的完整数据空间。由并发事务所做的修改必须与任何其他并发事务所做的修改隔离。事务查看数据更新时，数据所处的状态要么是另一事务修改它之前的状态，要么是另一事务修改它之后的状态，事务不会查看到中间状态的数据。\nDurability（持久性） 持久性，意味着在事务完成以后，该事务所对数据库所作的更改便持久的保存在数据库之中，并不会被回滚。\n事务隔离级别 # 数据库是要被广大客户所共享访问的，那么在数据库操作过程中很可能出现以下几种不确定情况：\n丢失修改：两个事务T1，T2读入同一数据并修改，T2提交的结果被T1破坏了，导致T1的修改丢失。（订票系统）\n不可重复读：事务T1读取数据后，事务T2执行更新操作，使T1无法再次读取结果。\n可以通过“读锁”和“写锁”解决不可重复读。读取数据的事务将会禁止写事务（但允许读事务），写事务则禁止任何其他事务。 读脏数据：事务T1修改某个数据并写回磁盘，事务T2读取同一数据，但T1由于某种原因撤销了，这时T1修改过的数据恢复原来的值，T2读取的数据就与数据库中的数据不一致。\n幻读：事务在操作过程中进行两次查询，第二次查询结果包含了第一次查询中未出现的数据（这里并不要求两次查询SQL语句相同）这是因为在两次查询过程中有另外一个事务插入数据造成的。\n为了避免上面出现几种情况在标准SQL规范中定义了4个事务隔离级别，不同隔离级别对事务处理不同 。\n未提交读（Read Uncommitted） 未提交读(READ UNCOMMITTED)是最低的隔离级别。允许脏读(dirty reads)，但不允许更新丢失，事务可以看到其他事务“尚未提交”的修改。\n提交读（Read Committed） 允许不可重复读取，但不允许脏读取。这可以通过“瞬间共享读锁”和“排他写锁”实现。读取数据的事务允许其他事务继续访问该行数据，但是未提交的写事务将会禁止其他事务访问该行。\n可重复读（Repeatable Read） 禁止不可重复读取和脏读取，但是有时可能出现幻读数据。这可以通过“共享读锁”和“排他写锁”实现。读取数据的事务将会禁止写事务（但允许读事务），写事务则禁止任何其他事务。\n可序列化(Serializable) 最高的隔离级别，它要求事务序列化执行，事务只能一个接着一个地执行，不能并发执行。仅仅通过“行级锁”是无法实现事务序列化的，必须通过其他机制保证新插入的数据不会被刚执行查询操作的事务访问到。\n隔离级别越高，越能保证数据的完整性和一致性，但是对并发性能的影响也越大。\n隔离级别的实现 # 数据库对于隔离级别的实现就是使用并发控制机制对在同一时间执行的事务进行控制，限制不同的事务对于同一资源的访问和更新，而最重要也最常见的并发控制机制，在这里我们将简单介绍三种最重要的并发控制器机制的工作原理。\n锁 锁是一种最为常见的并发控制机制，在一个事务中，我们并不会将整个数据库都加锁，而是只会锁住那些需要访问的数据项， MySQL 和常见数据库中的锁都分为两种，共享锁（Shared）和互斥锁（Exclusive），前者也叫读锁，后者叫写锁。\n读锁保证了读操作可以并发执行，相互不会影响，而写锁保证了在更新数据库数据时不会有其他的事务访问或者更改同一条记录造成不可预知的问题。\n时间戳 除了锁，另一种实现事务的隔离性的方式就是通过时间戳，使用这种方式实现事务的数据库，例如 PostgreSQL 会为每一条记录保留两个字段；读时间戳中包括了所有访问该记录的事务中的最大时间戳，而记录行的写时间戳中保存了将记录改到当前值的事务的时间戳。\n使用时间戳实现事务的隔离性时，往往都会使用乐观锁，先对数据进行修改，在写回时再去判断当前值，也就是时间戳是否改变过，如果没有改变过，就写入，否则，生成一个新的时间戳并再次更新数据，乐观锁其实并不是真正的锁机制，它只是一种思想，在这里并不会对它进行展开介绍。\n多版本和快照隔离 通过维护多个版本的数据，数据库可以允许事务在数据被其他事务更新时对旧版本的数据进行读取，很多数据库都对这一机制进行了实现；因为 所有的读操作不再需要等待写锁的释放，所以能够显著地提升读的性能， MySQL 和 PostgreSQL 都对这一机制进行自己的实现，也就是 MVCC ，虽然各自实现的方式有所不同，MySQL 就通过提到的 undo log 实现了 MVCC，保证事务并行执行时能够不等待互斥锁的释放直接获取数据。\nACID vs CAP # 数据库对于 ACID 中的一致性的定义是这样的：如果一个事务原子地在一个一致地数据库中独立运行，那么在它执行之后，数据库的状态一定是一致的。对于这个概念，它的第一层意思就是对于数据完整性的约束，包括主键约束、引用约束以及一些约束检查等等，在事务的执行的前后以及过程中不会违背对数据完整性的约束，所有对数据库写入的操作都应该是合法的，并不能产生不合法的数据状态。\nCAP 定理中的数据一致性，其实是说分布式系统中的各个节点中对于同一数据的拷贝有着相同的值；而 ACID 中的一致性是指数据库的规则，如果 schema 中规定了一个值必须是唯一的，那么一致的系统必须确保在所有的操作中，该值都是唯一的，由此来看 CAP 和 ACID 对于一致性的定义有着根本性的区别。\n数据库的一致性是：应用系统从一个正确的状态到另一个正确的状态.而 ACID 就是说事务能够通过 AID 来保证这个 C 的过程. C 是目的, AID 都是手段.\n使用事务 # 在MySQL中使用START TRANSACTION 或 BEGIN开启事务，提交事务使用COMMIT，ROLLBACK用来放弃事务。MySQL默认设置了事务的自动提交，即一条SQL语句就是一个事务。\n总结 # 事务的（ACID）特性是由关系数据库管理系统（RDBMS，数据库系统）来实现的。数据库管理系统采用日志来保证事务的原子性、一致性和持久性。日志记录了事务对数据库所做的更新，如果某个事务在执行过程中发生错误，就可以根据日志，撤销事务对数据库已做的更新，使数据库退回到执行事务前的初始状态。\n数据库管理系统采用锁机制来实现事务的隔离性。当多个事务同时更新数据库中相同的数据时，只允许持有锁的事务能更新该数据，其他事务必须等待，直到前一个事务释放了锁，其他事务才有机会更新该数据\n"},{"id":5,"href":"/post/test/","title":"Test","section":"Posts","content":"test\n"}]